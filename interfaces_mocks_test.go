// Code generated by MockGen. DO NOT EDIT.
// Source: interfaces.go

// Package traefik_fallback_plugin_test is a generated GoMock package.
package traefik_fallback_plugin_test

import (
	context "context"
	http "net/http"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	traefik_fallback_plugin "github.com/skynet2/traefik-fallback-plugin"
)

// MockFetcher is a mock of Fetcher interface.
type MockFetcher struct {
	ctrl     *gomock.Controller
	recorder *MockFetcherMockRecorder
}

// MockFetcherMockRecorder is the mock recorder for MockFetcher.
type MockFetcherMockRecorder struct {
	mock *MockFetcher
}

// NewMockFetcher creates a new mock instance.
func NewMockFetcher(ctrl *gomock.Controller) *MockFetcher {
	mock := &MockFetcher{ctrl: ctrl}
	mock.recorder = &MockFetcherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFetcher) EXPECT() *MockFetcherMockRecorder {
	return m.recorder
}

// CanFetch mocks base method.
func (m *MockFetcher) CanFetch() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CanFetch")
	ret0, _ := ret[0].(bool)
	return ret0
}

// CanFetch indicates an expected call of CanFetch.
func (mr *MockFetcherMockRecorder) CanFetch() *FetcherCanFetchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CanFetch", reflect.TypeOf((*MockFetcher)(nil).CanFetch))
	return &FetcherCanFetchCall{Call: call}
}

// FetcherCanFetchCall wrap *gomock.Call
type FetcherCanFetchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *FetcherCanFetchCall) Return(arg0 bool) *FetcherCanFetchCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *FetcherCanFetchCall) Do(f func() bool) *FetcherCanFetchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *FetcherCanFetchCall) DoAndReturn(f func() bool) *FetcherCanFetchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Fetch mocks base method.
func (m *MockFetcher) Fetch(ctx context.Context) (*traefik_fallback_plugin.CacheRecord, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Fetch", ctx)
	ret0, _ := ret[0].(*traefik_fallback_plugin.CacheRecord)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Fetch indicates an expected call of Fetch.
func (mr *MockFetcherMockRecorder) Fetch(ctx interface{}) *FetcherFetchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fetch", reflect.TypeOf((*MockFetcher)(nil).Fetch), ctx)
	return &FetcherFetchCall{Call: call}
}

// FetcherFetchCall wrap *gomock.Call
type FetcherFetchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *FetcherFetchCall) Return(arg0 *traefik_fallback_plugin.CacheRecord, arg1 error) *FetcherFetchCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *FetcherFetchCall) Do(f func(context.Context) (*traefik_fallback_plugin.CacheRecord, error)) *FetcherFetchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *FetcherFetchCall) DoAndReturn(f func(context.Context) (*traefik_fallback_plugin.CacheRecord, error)) *FetcherFetchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockCache is a mock of Cache interface.
type MockCache struct {
	ctrl     *gomock.Controller
	recorder *MockCacheMockRecorder
}

// MockCacheMockRecorder is the mock recorder for MockCache.
type MockCacheMockRecorder struct {
	mock *MockCache
}

// NewMockCache creates a new mock instance.
func NewMockCache(ctrl *gomock.Controller) *MockCache {
	mock := &MockCache{ctrl: ctrl}
	mock.recorder = &MockCacheMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCache) EXPECT() *MockCacheMockRecorder {
	return m.recorder
}

// Load mocks base method.
func (m *MockCache) Load(key string) (*traefik_fallback_plugin.CacheRecord, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Load", key)
	ret0, _ := ret[0].(*traefik_fallback_plugin.CacheRecord)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// Load indicates an expected call of Load.
func (mr *MockCacheMockRecorder) Load(key interface{}) *CacheLoadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Load", reflect.TypeOf((*MockCache)(nil).Load), key)
	return &CacheLoadCall{Call: call}
}

// CacheLoadCall wrap *gomock.Call
type CacheLoadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *CacheLoadCall) Return(arg0 *traefik_fallback_plugin.CacheRecord, arg1 bool) *CacheLoadCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *CacheLoadCall) Do(f func(string) (*traefik_fallback_plugin.CacheRecord, bool)) *CacheLoadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *CacheLoadCall) DoAndReturn(f func(string) (*traefik_fallback_plugin.CacheRecord, bool)) *CacheLoadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Store mocks base method.
func (m *MockCache) Store(key string, value *traefik_fallback_plugin.CacheRecord) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Store", key, value)
}

// Store indicates an expected call of Store.
func (mr *MockCacheMockRecorder) Store(key, value interface{}) *CacheStoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Store", reflect.TypeOf((*MockCache)(nil).Store), key, value)
	return &CacheStoreCall{Call: call}
}

// CacheStoreCall wrap *gomock.Call
type CacheStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *CacheStoreCall) Return() *CacheStoreCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *CacheStoreCall) Do(f func(string, *traefik_fallback_plugin.CacheRecord)) *CacheStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *CacheStoreCall) DoAndReturn(f func(string, *traefik_fallback_plugin.CacheRecord)) *CacheStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockTransport is a mock of Transport interface.
type MockTransport struct {
	ctrl     *gomock.Controller
	recorder *MockTransportMockRecorder
}

// MockTransportMockRecorder is the mock recorder for MockTransport.
type MockTransportMockRecorder struct {
	mock *MockTransport
}

// NewMockTransport creates a new mock instance.
func NewMockTransport(ctrl *gomock.Controller) *MockTransport {
	mock := &MockTransport{ctrl: ctrl}
	mock.recorder = &MockTransportMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransport) EXPECT() *MockTransportMockRecorder {
	return m.recorder
}

// RoundTrip mocks base method.
func (m *MockTransport) RoundTrip(arg0 *http.Request) (*http.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RoundTrip", arg0)
	ret0, _ := ret[0].(*http.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RoundTrip indicates an expected call of RoundTrip.
func (mr *MockTransportMockRecorder) RoundTrip(arg0 interface{}) *TransportRoundTripCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RoundTrip", reflect.TypeOf((*MockTransport)(nil).RoundTrip), arg0)
	return &TransportRoundTripCall{Call: call}
}

// TransportRoundTripCall wrap *gomock.Call
type TransportRoundTripCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TransportRoundTripCall) Return(arg0 *http.Response, arg1 error) *TransportRoundTripCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TransportRoundTripCall) Do(f func(*http.Request) (*http.Response, error)) *TransportRoundTripCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TransportRoundTripCall) DoAndReturn(f func(*http.Request) (*http.Response, error)) *TransportRoundTripCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
